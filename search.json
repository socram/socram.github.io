[
  
    {
      "title"    : "Desafio engenharia Reversa",
      "category" : "",
      "tags"     : "engenhariaReversa",
      "url"      : "https://socram.github.io/2021/01/08/desafio-mente-binaria-00/",
      "date"     : "08 January, 2021",
      "content"  : "Voltando a estudar binários resolvi documentar o passo a passo para resolver alguns desafio.\n\nO desafio eu achei no link do mente binaria:  https://www.mentebinaria.com.br/forums/topic/158-crackme-01-linux-geyslan/\n\nObjetivo:\n\n\nPatch\nSenha Válida\n\n\nAbaixo o código utilizado para os teste:\n/*\n\n  Crackme 01 - C Language - Linux/x86 and x86_64\n  Copyright (C) 2013 - Geyslan G. Bem, Hacking bits\n\n    http://hackingbits.com\n    geyslan@gmail.com \n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.\n\n*/\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/ptrace.h&gt;\n\n#define A(c) (char) (((int) (c)) ^ 108)\n\nchar passwd[8] = { A('w'), A('h'), A('y'), A('n'), A('0'), A('t') };\n\nvoid detect_gdb(void) __attribute__((constructor));\n\nvoid detect_gdb(void)\n{\n\n  FILE *fd = fopen(\"/tmp\", \"r\");\n  if (fileno(fd) &gt; 5)\n    {\n      printf(\"I'm sorry GDB! You are not allowed!\\n\");\n      exit(1);\n    }\n  fclose(fd);\n\n  if (ptrace(PTRACE_TRACEME, 0, 1, 0) &lt; 0) {\n    printf(\"Tracing is not allowed... Bye\\n\");\n    exit(1);\n  }\n\n}\n\nvoid xor(char *p)\n{\n  int i;\n\n  for (i = 0; i &lt; 6; i++)\n    {\n      p[i] ^= 108;\n    }\n}\n\nint compare(char *input, char *passwd)\n{\n  while (*input == *passwd)\n    {\n      if (*input == '\\0' || *passwd == '\\0' )\n    break;\n\n      input++;\n      passwd++;\n    }\n  if (*input == '\\0' &amp;&amp; *passwd == '\\0')\n    return 0;\n  else\n    return -1;\n}\n\nint main() {\n\n  char input[8];\n\n  fputs(\"Please tell me my password: \", stdout);\n\n  fgets(input, sizeof input -1, stdin);\n\n  xor(input);\n\n  if (compare(input, passwd) == 0)\n    fputs(\"The password is correct!\\nCongratulations!!!\\n\", stdout);\n  else\n    fputs(\"No! No! No! No! Try again.\\n\", stdout);\n\n  return 0;\n\n}\n\nCompilação\ngcc -o binario binario.c -fno-stack-protector -z execstack  -no-pie\n\nExecução :\n$ ./binario\nPlease tell me my password: aaaaaaaaaaaaaaaaaaaaaa\nNo! No! No! No! Try again.\n\nA ideia é colocar qualquer e passar, um exemplo disse seria um FLAG válida\n\nInformações sobre o binário compilado.\n$ file binario\nbinario: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=b277ed400d9e72d3d0567af1e1c12bd72f321720, not stripped\n\n\nEu sempre gosto de iniciar gerando alguns arquivos que vou usar posteriormente para a analise, os arquivos são: \n\n\nXXD &gt; binario.xxd\nOBJDUMP &gt; binario.objdump\nHEXDUMP &gt; binario.hexdump\n\n$ xxd binario &gt; binario.xxd\n$ objdump -dM intel binario &gt; binario.objdump\n$ hexdump -C binario &gt; binario.hexdump\n$ strings binario binario.strings\n\nComeço verificando as strings do binário. \n\nAbrindo o aquivo binario.strings  temos uma lista 106 strings, boa parte é coisa de compilação e podemos ignorar, porém da linhas 28 - 33 temos algumas informações interessantes. string utilizadas no programa\n  $ vi binario.strings\n\n 28 I'm sorry GDB! You are not allowed!\n 29 Tracing is not allowed... Bye\n 30 Please tell me my password:\n 31 The password is correct!\n 32 Congratulations!!!\n 33 No! No! No! No! Try again.\n\nAgora vamos abri o aquivo no gdb:\n$ gdb -q  binario\nReading symbols from binario...(no debugging symbols found)...done.\ngdb-peda$ run\nStarting program: /home/mconceicao/Desktop/teste-binario/binario\nTracing is not allowed... Bye\n[Inferior 1 (process 7103) exited with code 01]\n\n\nExiste uma trava no programa para nao deixar executar via GDB. Vamos remover isso.\n\nNo noso caso o arquivo nao está &ldquo;stripped&rdquo; entao podemos encontrar o nome das funções olhando o binario.objdump\n\nAgora eu abro o arquivo binario.objdump  e como nao está com &ldquo;stripped&rdquo; eu consigo olhar os nomes das funções.\n\nNa linha 193 temos a definição da funcao detect_gdb.\n193 0804861b &lt;detect_gdb&gt;:\n194  804861b: 55                    push   ebp\n195  804861c: 89 e5                 mov    ebp,esp\n196  804861e: 83 ec 18              sub    esp,0x18\n197  8048621: 83 ec 08              sub    esp,0x8\n198  8048624: 68 70 88 04 08        push   0x8048870\n199  8048629: 68 72 88 04 08        push   0x8048872\n200  804862e: e8 ad fe ff ff        call   80484e0 &lt;fopen@plt&gt;\n201  8048633: 83 c4 10              add    esp,0x10\n202  8048636: 89 45 f4              mov    DWORD PTR [ebp-0xc],eax\n203  8048639: 83 ec 0c              sub    esp,0xc\n204  804863c: ff 75 f4              push   DWORD PTR [ebp-0xc]\n205  804863f: e8 ac fe ff ff        call   80484f0 &lt;fileno@plt&gt;\n206  8048644: 83 c4 10              add    esp,0x10\n207  8048647: 83 f8 05              cmp    eax,0x5\n208  804864a: 7e 1a                 jle    8048666 &lt;detect_gdb+0x4b&gt;\n209  804864c: 83 ec 0c              sub    esp,0xc\n210  804864f: 68 78 88 04 08        push   0x8048878\n211  8048654: e8 57 fe ff ff        call   80484b0 &lt;puts@plt&gt;\n212  8048659: 83 c4 10              add    esp,0x10\n213  804865c: 83 ec 0c              sub    esp,0xc\n214  804865f: 6a 01                 push   0x1\n215  8048661: e8 5a fe ff ff        call   80484c0 &lt;exit@plt&gt;\n216  8048666: 83 ec 0c              sub    esp,0xc\n217  8048669: ff 75 f4              push   DWORD PTR [ebp-0xc]\n218  804866c: e8 0f fe ff ff        call   8048480 &lt;fclose@plt&gt;\n219  8048671: 83 c4 10              add    esp,0x10\n220  8048674: 6a 00                 push   0x0\n221  8048676: 6a 01                 push   0x1\n222  8048678: 6a 00                 push   0x0\n223  804867a: 6a 00                 push   0x0\n224  804867c: e8 7f fe ff ff        call   8048500 &lt;ptrace@plt&gt;\n225  8048681: 83 c4 10              add    esp,0x10\n226  8048684: 85 c0                 test   eax,eax\n227  8048686: 79 1a                 jns    80486a2 &lt;detect_gdb+0x87&gt;\n228  8048688: 83 ec 0c              sub    esp,0xc\n229  804868b: 68 9c 88 04 08        push   0x804889c\n230  8048690: e8 1b fe ff ff        call   80484b0 &lt;puts@plt&gt;\n231  8048695: 83 c4 10              add    esp,0x10\n232  8048698: 83 ec 0c              sub    esp,0xc\n233  804869b: 6a 01                 push   0x1\n234  804869d: e8 1e fe ff ff        call   80484c0 &lt;exit@plt&gt;\n235  80486a2: 90                    nop\n236  80486a3: c9                    leave\n237  80486a4: c3                    ret\n\nExistem &lsquo;N&rsquo; formas de desabilitar essa função, porém a que vou utilizar é a de desablitar o comportamento padrão dele, ou seja a função continua existendo porém seria uma funcao que nao faz nada, logo desabilitar o bloqueio do GDB.\n\nPara fazer isso vamos add a instrução RET no inicio da função e criar um aquivo de com o nosso patch.\n\nPara fazer isso vamos subistituir o push ebp por um ret ( return ) na primeira linha da função\n# Antes\n194  804861b: 55                    push   ebp\n\n# Depois do patch\n194  804861b: c3                    ret   \n\n\nPara fazer isso vamos abrir o arquivo binario com o vim utulizando o comando \n$ cp binario binario.patched\n$ vim -b  -c ':%!xxd' binario.patched\n\nPara esse caso, o jeito mais simples de aplicar o patch no binário foi procurar os byte usando o vim e substituindo na mão. \n\nCom o arquivo aberto vamos procurar os bits 55 89 e5 83 ec 18 que representão o inicio da função detect_gdb. Abaixo sublindo da onde tirei os bytes acima.\n193 0804861b &lt;detect_gdb&gt;:\n194  804861b: 55                    push   ebp\n195  804861c: 89 e5                 mov    ebp,esp\n196  804861e: 83 ec 18              sub    esp,0x18\n197  8048621: 83 ec 08              sub    esp,0x8\n198  8048624: 68 70 88 04 08        push   0x8048870\n Pesquisa realizada no vim: **/55 89e5 83ec**\n\n 92 000005b0: 1255 89e5 83ec 1050 6844 a004 08ff d283  .U.....PhD......\n 93 000005c0: c410 c9f3 c38d 7426 008d bc27 0000 0000  ......t&amp;...'....\n 94 000005d0: 803d 68a0 0408 0075 1355 89e5 83ec 08e8  .=h....u.U......\n 95 000005e0: 7cff ffff c605 68a0 0408 01c9 f3c3 6690  |.....h.......f.\n 96 000005f0: b810 9f04 088b 1085 d275 05eb 938d 7600  .........u....v.\n 97 00000600: ba00 0000 0085 d274 f255 89e5 83ec 1450  .......t.U.....P\n 98 00000610: ffd2 83c4 10c9 e975 ffff ff55 89e5 83ec  .......u...U....\n 99 00000620: 1883 ec08 6870 8804 0868 7288 0408 e8ad  ....hp...hr.....\n100 00000630: feff ff83 c410 8945 f483 ec0c ff75 f4e8  .......E.....u..\n101 00000640: acfe ffff 83c4 1083 f805 7e1a 83ec 0c68  ..........~....h\n102 00000650: 7888 0408 e857 feff ff83 c410 83ec 0c6a  x....W.........j\n103 00000660: 01e8 5afe ffff 83ec 0cff 75f4 e80f feff  ..Z.......u.....\n104 00000670: ff83 c410 6a00 6a01 6a00 6a00 e87f feff  ....j.j.j.j.....\n105 00000680: ff83 c410 85c0 791a 83ec 0c68 9c88 0408  ......y....h....\n106 00000690: e81b feff ff83 c410 83ec 0c6a 01e8 1efe  ...........j....\n107 000006a0: ffff 90c9 c355 89e5 83ec 10c7 45fc 0000  .....U......E...\n108 000006b0: 0000 eb1c 8b55 fc8b 4508 01d0 8b4d fc8b  .....U..E....M..\n\n# A parte VERDE é o que estamos procurando\n\nAgora precisamos mudar a a instrução 55 ( push ) por c3 ( ret ).\nAntes\n    98 00000610: ffd2 83c4 10c9 e975 ffff ff55 89e5 83ec  .......u...U....   \n    99 00000620: 1883 ec08 6870 8804 0868 7288 0408 e8ad  ....hp...hr.....   \n\nDepois\n    98 00000610: ffd2 83c4 10c9 e975 ffff ffc3 89e5 83ec  .......u........\n    99 00000620: 1883 ec08 6870 8804 0868 7288 0408 e8ad  ....hp...hr.....\n\nPara essa edição basta editar normalmente com o vim e para salvar\n:%!xxd -r\n:wq!\n\nComparando os hashs dos arquivos\n$ md5sum binario binario.patched\nc768b24761b7a1a3d99e8b9c61185bd4  binario\ndbbdaa0258da6334edd46c9583240526  binario.patched\n\nPronto agora já podemos executar o programa no GDB\n$ gdb binario.patched\ngdb-peda$ run\nStarting program: /home/mconceicao/Desktop/teste-binario/binario.patched\nPlease tell me my password: aaaaaaaaaaa\nNo! No! No! No! Try again.\n[Inferior 1 (process 8399) exited normally]\nWarning: not running\n\nAgora vamos aplicar outro patch para poder colocar qualquer senha e o programa imprimir \nThe password is correct!\nCongratulations!!!\n\nSeguindo a mesa lógica usada anteriormente vamos procurar na função main o trecho do código que verifica a senha colocada\n\nAbrindo o arquivo binario.objdump na linha 330 temos a chamada para umca função de compare\n330  8048791: e8 43 ff ff ff        call   80486d9 &lt;compare&gt;\n\nAnalizando a função\n080486d9 &lt;compare&gt;:\n262  80486d9: 55                    push   ebp\n263  80486da: 89 e5                 mov    ebp,esp\n264  80486dc: eb 1c                 jmp    80486fa &lt;compare+0x21&gt;\n265  80486de: 8b 45 08              mov    eax,DWORD PTR [ebp+0x8]\n266  80486e1: 0f b6 00              movzx  eax,BYTE PTR [eax]\n267  80486e4: 84 c0                 test   al,al\n268  80486e6: 74 22                 je     804870a &lt;compare+0x31&gt;\n269  80486e8: 8b 45 0c              mov    eax,DWORD PTR [ebp+0xc]\n270  80486eb: 0f b6 00              movzx  eax,BYTE PTR [eax]\n271  80486ee: 84 c0                 test   al,al\n272  80486f0: 74 18                 je     804870a &lt;compare+0x31&gt;\n273  80486f2: 83 45 08 01           add    DWORD PTR [ebp+0x8],0x1\n274  80486f6: 83 45 0c 01           add    DWORD PTR [ebp+0xc],0x1\n275  80486fa: 8b 45 08              mov    eax,DWORD PTR [ebp+0x8]\n276  80486fd: 0f b6 10              movzx  edx,BYTE PTR [eax]\n277  8048700: 8b 45 0c              mov    eax,DWORD PTR [ebp+0xc]\n278  8048703: 0f b6 00              movzx  eax,BYTE PTR [eax]\n279  8048706: 38 c2                 cmp    dl,al\n280  8048708: 74 d4                 je     80486de &lt;compare+0x5&gt;\n281  804870a: 8b 45 08              mov    eax,DWORD PTR [ebp+0x8]\n282  804870d: 0f b6 00              movzx  eax,BYTE PTR [eax]\n283  8048710: 84 c0                 test   al,al\n284  8048712: 75 11                 jne    8048725 &lt;compare+0x4c&gt;\n285  8048714: 8b 45 0c              mov    eax,DWORD PTR [ebp+0xc]\n286  8048717: 0f b6 00              movzx  eax,BYTE PTR [eax]\n287  804871a: 84 c0                 test   al,al\n288  804871c: 75 07                 jne    8048725 &lt;compare+0x4c&gt;\n289  804871e: b8 00 00 00 00        mov    eax,0x0\n290  8048723: eb 05                 jmp    804872a &lt;compare+0x51&gt;\n291  8048725: b8 ff ff ff ff        mov    eax,0xffffffff\n292  804872a: 5d                    pop    ebp\n293  804872b: c3                    ret\n\nNa linha 287 temos uma test (comparação) e em seguinda jne ( Jump not equals )  que na linha 289 atribui para o registrador eax  o valor 0x0 senão na linha 291 eax 0xffffffff.\n\nO nosso patch será o seguinte:\n\nIdepentende de true or false na comparação vamos atribuir o valor 0x0 para eax.\n$ cp binario.patched binario.patched.noPassword\n$ vim -b  -c ':%!xxd' binario.patched.noPassword\n\nProcurar a sequencia de bits eb 05 b8 ff ff ff ff 5d c3 \n Pesquisa realizada no vim: /eb 05b8 ffff ffff 5dc3\n\n113 00000700: 8b45 0c0f b600 38c2 74d4 8b45 080f b600  .E....8.t..E....\n114 00000710: 84c0 7511 8b45 0c0f b600 84c0 7507 b800  ..u..E......u...\n115 00000720: 0000 00eb 05b8 ffff ffff 5dc3 8d4c 2404  ..........]..L$.\n116 00000730: 83e4 f0ff 71fc 5589 e551 83ec 1465 a114  ....q.U..Q...e..\n117 00000740: 0000 0089 45f4 31c0 a164 a004 0850 6a1c  ....E.1..d...Pj.\n\n# A parte VERDE é o que estamos procurando\n\nAgora precisamos mudar a a instrução 55 ( push ) por c3 ( ret ).\nAntes\n  115 00000720: 0000 00eb 05b8 ffff ffff 5dc3 8d4c 2404  ..........]..L$.\n\nDepois\n  115 00000720: 0000 00eb 05b8 0000 0000 5dc3 8d4c 2404  ..........]..L$.\n\n\nPara essa edição basta editar normalmente com o vim e para salvar\n:%!xxd -r\n:wq!\n\nComparando Hashs\n$ md5sum binario binario.patched binario.patched.noPassword\nc768b24761b7a1a3d99e8b9c61185bd4  binario\ndbbdaa0258da6334edd46c9583240526  binario.patched\n44486b462e05f56655101b34555b952e  binario.patched.noPassword\n\nTestando binario com nosso patchs.\n./binario.patched.noPassword\nPlease tell me my password: aaaaaaaaaaaaaaaaaaaaaa\nThe password is correct!\nCongratulations!!!\n\nSucesso.\n\nFIM\n",
      "snippet"  : "Exercício proposto pela comunidade do mente binária"
    } 
  
  ,
  
   {
     
   } ,
  
   {
     
        "title"    : "About me",
        "category" : "",
        "tags"     : "",
        "url"      : "https://socram.github.io/about/",
        "date"     : " ",
        "content"  : "",
        "snippet"  : " "
     
   } ,
  
   {
     
   } ,
  
   {
     
   } ,
  
   {
     
   } ,
  
   {
     
        "title"    : "Search",
        "category" : "",
        "tags"     : "",
        "url"      : "https://socram.github.io/search/",
        "date"     : " ",
        "content"  : "",
        "snippet"  : " "
     
   } ,
  
   {
     
   } ,
  
   {
     
        "title"    : "Tags",
        "category" : "",
        "tags"     : "",
        "url"      : "https://socram.github.io/tags/",
        "date"     : " ",
        "content"  : "",
        "snippet"  : " "
     
   } ,
  
   {
     
   } 
  
]